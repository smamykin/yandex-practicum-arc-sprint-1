## Задание 1. 

### TL;DR; Описание сервисов
1. root-config - Это приложение контейнер. Содержит:
    1. верстку начальной страницы - /frontend/root-config/src/index.ejs
    2. подключения mf - /frontend/root-config/src/fourcheese-pizza-root-config.js.
    3. Стили, что используются в верстке начальной страницы (классы page, content, section, etc.)
2. mf-common. Содержит/Экспортирует (frontend/mf-common/src/fourcheese-pizza-mf-common.js):
    1. Ряда общих стилей (классы popup) + изображение close.svc (используется в popup)
    2. facade или "api-клиенты" к методам бэкенда utils/auth.js & api.js
    3. Экспортирует методы доступа к LocalStorage, где хранится jwt токен + туда складываем перс данные пользователя,
       которые требуются другим mf (mf-profile)
3. mf-profile. Содержит:
    1. Отрисовку (компоненты и стили) для отображения информации профиля:
        1. стили profile
        2. компоненты аватарки, имени, about.
        3. изображения, которые используются в этом блоке
    2. Компонент контекста для профайла. Если пользователь изменил данные, то mf кинет событие на document об этом,
       т.к.  для логики с карточками также требуется инфо о пользователе (id).
    3. Взаимодействия с апи происходят через методы, которые экспортировал mf-common
4. mf-auth. Содержит:
    1. Страницу логина
    2. Страниц регистрации
    3. Взаимодействия с апи происходят через методы, которые экспортировал mf-common
5. mf-cards:
    1. Стили, изображения и компоненты для отрисовки:
        1. Карточек
        2. Попапов добавляения и удаления
        3. Попап изображения
    2. Имеет свой компонент контекста - получает данные о пользователе (id) через события document и так поддерживает
       их актуальность
6. mf-header:
    1. содержит стили, изображения и компоненты для отрисовки шапки.
    2. Получает email пользователя c помощью mf-common (который управляет данными о авторизации в LocalStorage)
7. mf-footer - простой mf который содержит стили и компоненты для статичного футера.


### 1. Предварительный Анализ

#### Список components from App.js:
1. EditProfilePopup
2. AddPlacePopup
3. PopupWitForm (remove-card confirm)
4. EditAvatarPopup
5. ImagePopup
6. InfoTooltip
7. Header + Footer
8. Main (avatar,name, about of the current user + list of cards) - route "/"
9. Login (/signin)
10. Register (/signup)


#### Список components from styles
1. auth-from
2. card
3. content
4. footer+header
5. login
6. page
7. places
8. popup
9. profile


#### routes
/signin
/signup
/ (main, protectedroute) (Если мы не авторизованы то редиректит /signin)


#### deps:
1. testing:
   "@testing-library/jest-dom": "^5.11.4",
   "@testing-library/react": "^11.1.0",
   "@testing-library/user-event": "^12.1.10",
2. framework:
   "react": "^17.0.2",
   "react-dom": "^17.0.2",
   "react-scripts": "4.0.3",
3. routing:
   "react-router-dom": "^5.2.0",
4. monitoring:
   "web-vitals": "^1.0.1"

#### state:
React.useState + context, LocalStorage

#### utils:
api.js - api client for backend (content + media)
auth.js - api for authentication and authorization 

### 2. Бизнес функции и команды
1. Профиль пользователя  
2. Авторизация
3. Галерея карточек

Для каждой функции будет выделена команда для развития + требуется команда платформы (Общий функционал и 
кросс-командное взаимодействие)

#### список мф

1. приложение-контейнер - root-config (владелец: Команда Платформы)
2. header + footer (владелец: Команда Платформы)
3. mf-profile (владелец: Команда Профиля)
4. mf-auth (владелец: Команда Авторизации)
5. mf-cards (владелец: Команда Команда Карточек)
6. mf-common (владелец: Команда Платформы)

### 3. Метод реализации

#### runtime ИЛИ build time ?
Предположим что есть несколько команд (раз нам пришла в голову идея разделить это приложение), которые хотят 
разрабатывать независимо. Так же предположим что у нас уже используется k8s и настроить CI/CD для нас не проблема.

В этом случае выбираем runtime метод интеграции. 

Т.к. build time имеет ряд недостатков. Самые неприятные из них:
1. Если появятся изменения в зависимостях, вам придётся развёртывать пакет заново.
2. Нужно синхронизировать разные версии библиотек, иначе возникнут проблемы со сборкой.

А плюсы - упрощение развертывания, тесное взаимодействие ф-й, оптимизация производительности - исходя из предположений,
для нас не входят в ключевые требования

Runtime метод же больше подходит под предположения. 

#### Метод компоновки

Судя по функционалу (основной роут закрыт за авторизацией) плюсы серверной компоновки - подходит для SEO - нем не нужны. 
Усложнять логику с Service Side Rendering мы также не хотим.
Поэтому выбираем клиентскую компоновку.

### Инструмент

Предположим что проект планируют развивать. В частности: появится новый функционал с большим количеством форм.
Мы не знаем какой фреймворк мы выберем для нового функционала и хотим отложить это решение на потом - в компании нет 
каких-то регламентов, что надо обязательно использовать React. Так, чтобы оставить себе возможность выбрать фреймворк
в будущем, сейчас мы выбираем Single SPA.

### Межмодульное взаимодействие
1. Персональные данные пользователя и токен (email, jwt токен) хранится в локал сторедж, как это и было ранее. 
2. Состояние профиля и контент хранятся на сервере. Для упрощения используются Js события для оповещения других 
     компонентов если данные профиля изменились.
3. Общий react-контекст (с данными пользователя) продублирован в микрофронтах в которых он требуется. mf-profile 
    является владелцем этих данных и только он может изменять эти данные. После этого он оповещает остальные модули 
    о изменении через js-событие.
